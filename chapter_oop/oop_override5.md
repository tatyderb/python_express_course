# Арифметические операции

Рассмотрим арифметические операции на примере сложения. Возможные варианты сложения:
```python
x + y       # x и y - объекты одного класса
x + 12      # складываем объект с другим типом
12 + x      # складываем другой тип с объектом
x += y      # сложение с присваиванием
```
## \_\_add\_\_, \_\_radd\_\_, \_\_iadd\_\_

Чем отличаются эти методы и какие операции реализуют?

Пусть в классе Drob реализован метод \_\_add\_\_, который складывает две дроби.

Что делать, если хотим сложить дробь с числом опишем потом.

Что делать, если хотим сложить число с дробью: `3 + Drob(1, 2)`. Метод \_\_add\_\_ класса Drob будет вызван, если левый операнд - дробь. Если дробь прибавляем к int, то должен вызываться метод \_\_add\_\_ класса int (который ничего не знает о классе Drob).

Метод **\_\_radd\_\_** класса вызывается, когда экземпляр класса находится справа от +, а слева от + не является экземпляром класса.

```python
>>> class Commuter:
...     def __init__(self, val):
...         self.val = val
...     def __add__(self, other):
...         print('add', self.val, other)
...         return self.val + other # если other экземпляр этого же класса, то получим вызов __radd__
...     def __radd__(self, other):
...         print('radd', self.val, other)
...         return other + self.val
...
>>> x = Commuter(88)
>>> y = Commuter(99)
>>> x + 1 # __add__: экземпляр + не_экземпляр
add 88 1
89
>>> 1 + y # __radd__: не_экземпляр + экземпляр
radd 99 1
100
>>> x + y # __add__: экземпляр + экземпляр
add 88 <__main__.Commuter instance at 0x02630910>
radd 99 88
187
```

Разберем порядок вызовов при x+y. Так как х слева и у него есть метод \_\_add\_\_, вызывается этот метод.

При вызове метода \_\_add\_\_ доходим до вычисления `self.val + other` и self.val тут число, а other - объект класса, значит вызывается `other.__radd(self.val)`.

Если результатом операции должен быть экземпляр класса, то его нужно вернуть. Если мы пишем неизменяемый тип, то создать новый экземпляр.

Заметьте, если не проверить в \_\_add\_\_, что other тоже экземпляр класса, то получим бесконечную рекурсию:
```python
>>> class Commuter: # Тип класса распространяется на результат
...     def __init__(self, val):
...         self.val = val
...     def __add__(self, other):
...         if isinstance(other, Commuter): other = other.val
...             return Commuter(self.val + other)
...     def __radd__(self, other):
...         return Commuter(other + self.val)
...     def __str__(self):
...         return '<Commuter: %s>' % self.val
...
>>> x = Commuter(88)
>>> y = Commuter(99)
>>> print(x + 10)       # Результат – другой экземпляр класса Commuter
<Commuter: 98>
>>> print(10 + y)
<Commuter: 109>
>>> z = x + y           # Нет вложения: не происходит рекурсивный вызов __radd__
>>> print(z)
```

Какие методы будут вызваны, если в классе Drob1 реализован метод \_\_add\_\_, в классе Drob2 реализован метод \_\_radd\_\_, и вычисляется выражение Drob1(1, 2) + Drob2(1, 2) (если классы не связаны отношением наследования)? Вызывается метод \_\_add\_\_ для **левого** операнда.

**Правосторонние методы реализуют, если в класс должен поддерживать перестановку операндов.** 

Классу Drob такой метод нужен. Классу Student - скорее всего нет.

## += - изменение объекта

Оператор += реализован через метод \_\_iadd\_\_. Если его нет, вызывается \_\_add\_\_.

В \_\_iadd\_\_ можно изменять сам объект, не создавая новые объекты (как list.extend).

```python
>>> class Number1:
...     def __init__(self, val):
...         self.val = val
...     def __iadd__(self, other):  # __iadd__ явно реализует операцию x += y
...         self.val += other       # Обычно возвращает self
...         return self
...
>>> x = Number1(5)
>>> x += 1
>>> x += 1
>>> x.val
7
>>> class Number2:
... def __init__(self, val):
...     self.val = val
... def __add__(self, other):       # __add__ - как крайнее средство: x=(x + y)
...     return Number2(self.val + other) # Распространяет тип класса
...
>>> x = Number2(5)
>>> x += 1
>>> x += 1
>>> x.val
7
```

Другие арифметические операции имеют аналогичный набор методов.
