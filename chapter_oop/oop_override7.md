## \_\_repr\_\_ и \_\_str\_\_ - представим объект в виде строки

**Эти методы должны вернуть строку**

Эти методы вызываются, когда объект пытаются преобразовать в строку:
```python
>>> class A:
...     def __str__(self):  return 'call str'
...     def __repr__(self): return 'call repr'
...
>>> x = A()
>>> x
call repr
>>> b = [x]
>>> b
[call repr]
>>> print(x)
call str
>>> str(x)
'call str'
>>> repr(x)
'call repr'
```
* **\_\_str\_\_** - пытается вызваться при print() и str(); показывает объект для пользователя.
* **\_\_repr\_\_** - в остальных случаях; содержит полезный для разработчика код (для отладки) или строку, которую можно выполнить и воссоздать этот объект.

**Если метода \_\_str\_\_ нет, то будет пытаться вызваться метод \_\_repr\_\_**. Но не наоборот, если есть только \_\_repr\_\_, то не будут пытаться вместо нее вызвать \_\_str\_\_ (Вдруг нужно полученную строку потом будет выполнять, а результат str выполнять не предполагается).

## \_\_add\_\_, \_\_radd\_\_, \_\_iadd\_\_

Чем отличаются эти методы и какие операции реализуют?

Пусть в классе Drob реализован метод \_\_add\_\_, который складывает две дроби.

Что делать, если хотим сложить дробь с числом опишем потом.

Что делать, если хотим сложить число с дробью: `3 + Drob(1, 2)`. Метод \_\_add\_\_ класса Drob будет вызван, если левый операнд - дробь. Если дробь прибавляем к int, то должен вызываться метод \_\_add\_\_ класса int (который ничего не знает о классе Drob).

Метод **\_\_radd\_\_** класса вызывается, когда экземпляр класса находится справа от +, а слева от + не является экземпляром класса.

```python
>>> class Commuter:
...     def __init__(self, val):
...         self.val = val
...     def __add__(self, other):
...         print('add', self.val, other)
...         return self.val + other # если other экземпляр этого же класса, то получим вызов __radd__
...     def __radd__(self, other):
...         print('radd', self.val, other)
...         return other + self.val
...
>>> x = Commuter(88)
>>> y = Commuter(99)
>>> x + 1 # __add__: экземпляр + не_экземпляр
add 88 1
89
>>> 1 + y # __radd__: не_экземпляр + экземпляр
radd 99 1
100
>>> x + y # __add__: экземпляр + экземпляр
add 88 <__main__.Commuter instance at 0x02630910>
radd 99 88
187
```

Разберем порядок вызовов при x+y. Так как х слева и у него есть метод \_\_add\_\_, вызывается этот метод.

При вызове метода \_\_add\_\_ доходим до вычисления `self.val + other` и self.val тут число, а other - объект класса, значит вызывается `other.__radd(self.val)`.

Если результатом операции должен быть экземпляр класса, то его нужно вернуть. Если мы пишем неизменяемый тип, то создать новый экземпляр.

Заметьте, если не проверить в \_\_add\_\_, что other тоже экземпляр класса, то получим бесконечную рекурсию:
```python
>>> class Commuter: # Тип класса распространяется на результат
... def __init__(self, val):
... self.val = val
... def __add__(self, other):
... if isinstance(other, Commuter): other = other.val
... return Commuter(self.val + other)
... def __radd__(self, other):
... return Commuter(other + self.val)
... def __str__(self):
... return ‘<Commuter: %s>’ % self.val
...
>>> x = Commuter(88)
>>> y = Commuter(99)
>>> print(x + 10) # Результат – другой экземпляр класса Commuter
<Commuter: 98>
>>> print(10 + y)
<Commuter: 109>
>>> z = x + y # Нет вложения: не происходит рекурсивный вызов __radd__
>>> print(z)
```

Какие методы будут вызваны, если в классе Drob1 реализован метод \_\_add\_\_, в классе Drob2 реализован метод \_\_radd\_\_, и вычисляется выражение Drob1(1, 2) + Drob2(1, 2) (если классы не связаны отношением наследования)? Вызывается метод \_\_add\_\_ для **левого** операнда.




# Задачи

Напишите класс Drob, который представляет дроби в виде _целых_ числителя и знаменателя.

```python
class Drob(object):
    """ Дробь вида a/b"""
    def __init__(self, a=0, b=1):
        self.a = a
        self.b = b
        self.normalize()
        
    def normalize(self):
        """ Приводит дробь вида 4/6 к 2/3"""
        
    def __str__(self):
        return '{}/{}'.format(self.a, self.b)
        
    # реализуйте функции
    # __eq__
    # __lt__
    # __add__
    # __sub__
    # __mul__
    # __truediv__
    # __floordiv__
    # __mod__
    # и ПРОВЕРЬТЕ каждую функцию
```

Этот класс нам понадобится, когда будем изучать тестирование. Сохраните его, пожалуйста.