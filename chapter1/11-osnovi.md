## Переменные и типы данных

Переменные не нужно объявлять заранее. 
**У переменных нет типа. Тип есть только у данных, на которые указывают переменные**. 
Для опредения типа используют функцию **type()**
```python
x = 5
print(x)         # 5
print(type(x))   # <class 'int'>

x = 3.14
print(x)         # 3.14
print(type(x))   # <class 'float'>

x = 'Hello'
print(x)         # Hello
print(type(x))   # <class 'str'>
```
int, float, str, bool, complex - встроенные типы данных языка. Они **unmutable** (неизменяемые). (Только неизменяемые данные могут быть ключами в словаре).

## Ссылки на объекты

Все переменные содержат только ссылки на объекты.

Оператор = связывает переменную с объектом в памяти через ссылку. Если переменная уже существует, то справа от = напишем ссылку на объект, которая будет храниться в переменной. Если переменной еще нет, то оператор = создает переменную и записывает в нее ссылку (которая указана справа от =).

![](/assets/reference.png)

Для упрощения рисунков дальше вместо ссылок на неизменяемые объекты будем рисовать переменные со значением.

```python
>>> a = 3
```
1. Создается объект, представляющий число 3 (так как объект неизменяемый, то он создается только если его еще нет, но с логической точки зрения можете считать, что каждый раз создается новый объект).
2. Создается переменная a, если ее еще нет.
3. В переменную а записывается ссылка на объект, представляющий число 3. 

Термины:
**Переменная** - запись в системной таблице, где предусмотрено место для хранения ссылок на объекты.
**Объект** - это область памяти с объемом, достаточным для представления значения этого объекта.
**Ссылка** – это автоматически разыменовываемый указатель на объект.

Объект содержит _описатель типа_ и _счетчик ссылок_. В описателе типа хранится информация о типе объекта. Счетчик ссылок нужен для автоматического удаления объектов.

### Сборка мусора

В Python **объекты удаляются автоматически сборщиком мусора**, если на них нет ссылок.
Сборка мусора (**garbage collection**) работает так же для каскадов объектов (на которые нет ссылок, или набор объектов с циклическими ссылками).

TODO: Иллюстрация понятия живых объектов и "мусора".

Принципы работы сборщика мусора:
* Убирается не сразу, когда объект стал мусором, а когда ему вздумается;
* Может не убираться, если есть хватает памяти;
* Можно "попросить убраться".

**gc** - модуль garbage collector.

### Бывает ли memory leak в питоне?

Формально, вы не можете "потерять память". Но если вы держите ссылки на ненужные объекты, они остаются в памяти.

```python
x = get_big_big_object()  # x ссылается на большой объект
...
x = None                  # когда объект не нужен, можно перестать на него ссылаться
del x                     # или вообще удалить переменную
```

### None - этого не может быть

```python
>>> x = None
>>> x
>>> print(x)
None
>>> type(x)
<class 'NoneType'>
>>> x is None
True
>>> 12 is not None    # проверка, что это не None (PEP-8)
True
>>> not 12 is None    # тоже работает, но PEP-8 это не одобряет
True
>>> x == None   
True
>>> x != None
False
```

## Идентификаторы

Описаны в PEP 3131

* Первый символ должен быть либо _ либо алфавитным символом a-zA-Z либо алфавитным символом большинства алфавитов
* следующие символы могут так же содержать любой непробельный символ (например, цифры и символ Каталана)
* не быть ключевым словом (if, for, while и тп.)
* не пересекаться с предопределенными именами
  * чтобы узнать какие имена предопределены, используйте функцию dir(\_\_builtins\_\_)
* начинаются с \_\_ и заканчиваются им специальные методы: \_\_init\_\_, \_\_lt\_\_ и прочие 
* \_ и \_\_ в начале идентификатора может влиять на область его видимости

## Физические и логические строки. Точка с запятой

_Физическая строка_ - то, что вы видите на экране, набирая код программы.

_Логическая строка_ - то, что питон видит как единое предложение.

Неявно предполагается, что одной физической строке соотвествует одна логическая.

Последним символом строки можно поставить **\\** и написать одну логическую строку на двух физических.

Можно можно на одной физической строке написать несколько логических, разделяя их ;

```
i = i+5; print(i)  # можно поставить ; в конце каждой строки, как вы привыкли в С++
```

Не ставьте лишние символы ; Они зашумляют чтение кода и показывают, что это "ваша первая программа на питоне".


## Отступы

**Отступы** - это пробелы или табуляции в _начале_ строки. Они важны.

Уровни вложенности в питоне обозначаются не скобками, а отступами.

Придерживайтесь одного стиля отступов - ЛИБО пробелы (рекомендовано 4), ЛИБО табуляции (одна). Не смешивайте их. В другом редакторе могут быть другие настройки табуляции и отступов (например, 1 табуляция = 8 пробелов) и тогда ваша логическая структура программы приобретет совсем другой вид.

Этот код не будет работать:
```
i = i+5
 print(i)       # Ошибка, лишний пробел в начале строки
print('Hello')
```

### Поменять местами значение переменных x и y

```python
x, y = y, x
```

Как это работает обсудим позже.

### str

Строки можно писать в одинарных, двойных и тройных кавычках. Строки могут содежать любые символы юникода.

```
'Hello'
"Здесь могут быть русские буквы или другие символы юникода"
'''Текст на 
несколько строк'''
```
Строки - неизменяемый тип данных. Нельзя изменить существующую строку, можно создать новую.

Подробнее строки и операции над ними будут рассмотрены позже.