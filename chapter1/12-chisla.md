Все типы, описанные в разделе, являются неизменяемыми.

## Целочисленные типы

* Логические выражения:
  * False и 0 - это False
  * True и любые числа кроме 0 - это True
* Численные выражения:
  * True - это 1
  * False - это 0

```python
i += True     # синтаксически верно и увеличивает на 1, но НЕ ПИШИТЕ ТАК
i += 1        # то же самое, лучше писать так

x = bool(7)   # x == True
x = bool(-7)  # x == True
x = bool(0)   # x == False
```

### int

int - целые положительные и отрицательные числа. Размер не ограничен.

```python
x = 2**217  # 2 в степени 217
print(x)    # 210624583337114373395836055367340864637790190801098222508621955072
```

### Как создаются целочисленные объекты?
Для других типов объектов похожие правила.
Вызывается функция int

* без аргументов int() - создаст целое число 0. Аналогично любые другие встроенные типы данных без аргумента создают какой-то объект со значением по умолчанию;
* с одним аргументом 
   * int(12) - поверхностная копия
   * int('123'), int(4.56) - если тип аргумента подходящий, то происходит преобразование. Если оно неудачное, например, int('Hello'), то возбуждается исключение ValueError, если тип неподходящий, например, int([1, 2, 3]), то исключение TypeError
* с двумя аргументами int(x, base) - аналогично, ибо в одном аргументе по умолчанию base=10 (подробнее далее)

#### Функции преобразования целых чисел

| Синтаксис | Описание |
| --- | --- |
| bin\(i\) | Возвращает двоичное представление целого числа i в виде строки, например, bin\(1980\) == '0b11110111100' |
| hex\(i\) | Возвращает шестнадцатеричное представление целого числа i в виде строки, например, hex\(1980\) == '0x7bc' |
| int\(x\) | Преобразует объект x в целое число; в случае ошибки во время преобразования возбуждает исключение ValueError, а если тип объекта x не поддерживает преобразование в целое число, возбуждает исключение TypeError. Если x является числом с плавающей точкой, оно преобразуется в целое число путем усечения дробной части. |
| int\(s, base\) | Преобразует строку s в целое число, в случае ошибки возбуждает исключение ValueError. Если задан необязательный аргумент base, он должен быть целым числом в диапазоне от 2 до 36включительно. |
| oct\(i\) | Возвращает восьмеричное представление целого числа i в виде строки, например, oct\(1980\) == '0o3674' |

```python
>>> s1 = bin(10)   # получаем из числа 10 строки для представления числа в бинарной, восьмеричной и шестнадцатеричной системах счисления
>>> s1
'0b1010'
>>> s2 = oct(10)
>>> s2
'0o12'                  # Заметьте, что префикс **0o**, а не просто 0, как в языке С.
>>> s3 = hex(10)
>>> s3
'0xa'
>>> x1 = int('10')      # из строки - десятичного представления числа - получаем целое число типа int
>>> x1; type(x1)
10
<class 'int'>
>>> x1 = int('  10  ')  # **допускает пробельные символы до и после числа**
>>> x1
10
>>> x2 = int(s1, 2)     # обратно из бинарной строки в целое число
>>> x2; type(x2)
10
<class 'int'>
>>> x2 = int('111', 2)  # обратно из бинарной строки в целое число
>>> x2
7
>>> x3 = int('z', 36)   # параметр base может быть от 2 до 36, цифры тогда 0-9a-zA-Z
>>> x3
35
>>> x3 = int('Az', 36)  
>>> x3
395
```
Для преобразования стандартных типов данных используются функци
* **int(x, base=10)**
* **float(x)**
* **str(x)** 
* **bool(x)** 
* **complex(re, im)**


### Побитовые операции над целыми числами

| **Синтаксис** | **Описание** |
|---|---|
| i \| j | Битовая операция OR (ИЛИ) над целыми числами i и j; отрицательные числа представляются как двоичное дополнение |
| i ^ j  | Битовая операция XOR (исключающее ИЛИ) над целыми числами i и j |
| i & j  | Битовая операция AND (И) над целыми числами i и j |
| i << j  | Сдвигает значение i влево на j битов аналогично операции i \* (2 ** j) без проверки на переполнение |
| i >> j  | Сдвигает значение i вправо на j битов аналогично операции i // (2 ** j) без проверки на переполнение |
| ~i  | Инвертирует биты числа i |


### bool

**True** и **False** - константы. 

Операторы and, or, not.

НЕ используйте 1 и 0 вместо True и False (понижает читаемость кода).

## Числа с плавающей точкой

В стандартной библиотеке это float, complex и decimal.Decimal 

## float

Константы записываются как 0.0, 4., 5.7, –2.5, –2e9, 8.9e–4.

Обычно реализованые типом double языка С. Подробнее смотри [sys.float_info](https://docs.python.org/3/library/sys.html#sys.float_info)
Поэтому часть чисел может быть представлена точно (0.5), а часть - только приблизительно (0.1).

Можно написать простую функцию, которая сравнивает числа с машинной точностью:
```
def equal_float(a, b):
    return abs(a  b) <= sys.float_info.epsilon
```

#### Округление

Все  numbers.Real типы \(int и float\) могут быть аргументами следующих функций :

| Операция | Результат |
| --- | --- |
| int\(x\) | Округляет число в сторону нуля. Это стандартная функция, для ее использования не нужно подключать модуль math |
| round\(x\) | Округляет число до ближайшего целого. Если дробная часть числа равна 0.5, то число округляется до ближайшего четного числа |
| round\(x, n\) | Округляет число x до n знаков после точки. Это стандартная функция, для ее использования не нужно подключать модуль math |
| math.floor\(x\) | Округляет число вниз \(«пол»\), при этом floor\(1.5\) = 1, floor\(-1.5\) = -2 |
| math.ceil\(x\) | Округляет число вверх \(«потолок»\), при этом ceil\(1.5\) = 2, ceil\(-1.5\) = -1 |
| math.trunc\(x\) | Отбрасывает дробную часть |

Примеры:

| Выражение | Результат |
|---|---|
| int(1.7) | 1 |
| int(-1.7) | -1 |
| ceil(4.2) | 5 |
| ceil(4.8) | 5 |
| ceil(-4.2) | -4 |
| round(1.3) | 1 |
| round(1.7) | 2 |
| round(1.5) | 2 |
| round(2.5) | 2 |
| round(2.65, 1) | 2.6 |
| round(2.75, 1) | 2.8 |
| trunc(5.32) | 5 |
| trunc(-5.32) | -5 |

Сюрпризы:

```python
round(2.85, 1)   # 2.9
```
подробнее:
[Floating Point Arithmetic: Issues and Limitations](https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues)

### Бесконечность и NaN (not a number)

Создаем бесконечность, отрицательную бесконечность и NaN

```python
>>> a = float('inf')
>>> b = float('-inf')
>>> c = float('nan')
>>> a
inf
>>> b
-inf
>>> c
nan
>>>
```

#### Проверяем эти особые значения функциями **math.isinf()** и **math.isnan()**

```python
>>> math.isinf(a)
True
>>> math.isinf(b)
True
>>> math.isnan(c)
True
>>> b < 0
True
```
#### Операции над бесконечностью интуитивно понятны математику:

```python
>>> a = float('inf')
>>> a + 45
inf
>>> a * 10
inf
>>> 10 / a
0.0
```

#### Когда получается **nan** ?

```python
>>> a = float('inf')
>>> a/a
nan
>>> b = float('-inf')
>>> a + b
nan
```

#### Из nan получается только nan

```python
>>> c = float('nan')
>>> c + 23
nan
>>> c / 2
nan
>>> c * 2
nan
>>> math.sqrt(c)
nan
```

#### Не сравнивайте nan

```
>>> c = float('nan')
>>> d = float('nan')
>>> c == d
False
>>> c is d
False
```

#### Возбудить исключение, когда результат nan

Иногда при отладке нужно поймать, где возникло "не то значение". Используйте модуль [fpectl]()





### complex
Для представления комплесных чисел есть встроенный тип complex. Мнимая единица обозначается как j или J.

При конвертации из строки вокруг + или - НЕ должно быть пробелов

```python
x = complex(3, 5) # 3+5j
x = complex(3.5) # 3.5+0j
x = complex(' 3+5j ') # 3+5j
x = complex('3 + 5j') # ОШИБКА
```

Для работы с комплексными числами используйте функции из модуля cmath.

## Decimal

Если нужна бОльшая точность, чем дает float, используйте decimal.Decimal.

Эти числа обеспечивают уровень точности, который вы укажете (по умолчанию 28 знаков
после запятой), и могут точно представлять периодические числа, такие как 0.11, но скорость работы с такими числами существенно ниже,
чем с обычными числами типа float. Вследствие высокой точности числа типа decimal.Decimal прекрасно подходят для производства финансовых вычислений.

## Раличные типы в бинарных операторах

| Тип операторов | Тип результата |
|---|---|
| int float | float |
| float complex | complex |
| Decimal int | Decimal |

Decimal может использоваться только с Decimal или int, нельзя его использовать с float и другими неточными типами.

## Действия над числами

| Синтаксис | Описание |
| --- | --- |
| x + y | Складывает число x и число y |
| x  y | Вычитает число y из числа x |
| x \* y | Умножает x на y |
| x / y | Делит x на y – результатом всегда является значение типа float \(или complex, если x или y является комплексным числом\) |
| x // y | Делит x на y, результат округляется вниз -7//2 == -4 |
| x % y | Возвращает модуль \(остаток\) от деления x на y. Для комплексных чисел преобразуется с помощью abs\(\) к float |
| x \*\* y | Возводит x в степень y, смотрите также функцию pow\(\) |
| -x | Изменяет знак числа. 0 остается нулем. |
| +x | Ничего не делает, иногда используется для повышения удобочитаемости программного кода |
| abs\(x\) | Возвращает абсолютное значение x |
| divmod\(x, y\) | Возвращает частное и остаток деления x на y в виде кортежа двух значений типа int |
| pow\(x, y\) | Возводит x в степень y; то же самое, что и оператор \*\* |
| pow\(x, y, z\) | Более быстрая альтернатива выражению \(x \*\* y\) % z |
| round\(x, n\) | Возвращает значение типа int, соответствующее значению x типа float, округленному до ближайшего целого числа \(или значение типа float, округленное до n-го знака после запятой, если задан аргумент n\) |

### Комбинированные операторы присвоения

+= -= *= /= //= %= и прочие операторы

### Как работает ++ и --

Никак. Их нет в языке. Используйте x += 1 и x -= 1. В циклах можно обойтись без них.