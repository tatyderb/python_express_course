# Шаблоны проектирования

Как использовать классы для решения задач (архитектура)?

* наследование
* композиция
* делегирование
* фабрики

Три кита ООП:
* наследование 
Основано на механизме поиска атрибутов объекта в выражении `x.atr`
* полиморфизм
Значение выражения `x.method` зависи от того, какого типа объект х.
* инкапсуляция
по умолчанию данные спрятаны, поведение объекта реализуем через методы.

## Перегрузка (overload) функций

Так как в питоне нет объявления типов (в агрументах функций объявлений точно нет), то нет и обычной для других языков (C++, Java) перегрузки, когда реализуем методы с одинаковым именем, но разным набором аргументов (различается количество и/или тип аргументов).

```python
class C:
    def meth(self, x):
        ...
    def meth(self, x, y, z):
        ...
```
Это работоспобоный код. У нас выполняется 2 присваивания. Один за другим. Все равно, что сначала написать x = 1, а потом x = 2. (Определение функции - это тоже операция присвоения).


## isinstance

Можно реализовать через \*args и проверку **isinstance**

```python
>>> x = 3
>>> isinstance(x, int)
True
>>> isinstance(x, str)
False
```

**isinstance** определяет и базовые классы в наследованииё
```python
>>> class A(object): 
      pass
...
>>> class B(A): 
       pass
...
>>> x = B()
>>> x
<__main__.B object at 0xffd77f70>
>>> isinstance(x, A)
True
>>> isinstance(x, B)
True
>>> isinstance(x, int)
False
```
Лучше не писать проверки аргументов функции на тип, а использовать полиморфизм:
```python
class C:
    def meth(self, x):
        x.operation()   # Предполагается, что x работает правильно
```
