# Контрольные вопросы и ответы по разделам

Лутц, стр 621

## Контрольные вопросы
1. Каким образом файл с исходным программным кодом модуля превращается в объект модуля?
2. Зачем может потребоваться настраивать значение переменной окружения
PYTHONPATH?
3. Назовите четыре основных компонента, составляющих путь поиска модулей.
4. Назовите четыре типа файлов, которые могут загружаться операцией импортирования.
5. Что такое пространство имен, и что содержит пространство имен модуля?

## Ответы
1. Файл с исходными текстами модуля автоматически превращается в объект модуля в результате выполнения операции импортирования. С технической точки зрения исходный программный код модуля выполняется во
время импортирования, инструкция за инструкцией, и все имена, которым
по мере выполнения операций будут присвоены значения, превращаются
в атрибуты объекта модуля.
2. Настройка переменной PYTHONPATH может потребоваться только в случае необходимости импортировать модули, размещенные в каталогах, отличных
от того, в котором вы работаете (то есть отличных от текущего каталога при
работе в интерактивной оболочке или от каталога, где находится главный
файл программы).
3. Четырьмя основными компонентами, составляющими путь поиска модулей, являются: домашний каталог главного файла программы (каталог,
в котором он находится), все каталоги, перечисленные в переменной окружения PYTHONPATH, каталоги стандартной библиотеки и все каталоги в файлах с расширением .pth, размещенных в стандартных местах. Из них доступны для настройки переменная окружения PYTHONPATH и файлы с расширением .pth.
4. Интерпретатор Python может загружать файлы с исходными текстами
(.py), файлы с байт-кодом (.pyc), файлы расширений, написанных на языке C (например, файлы с расширением .so в Linux или с расширением .dll
в Windows), или каталог с указанным именем, в случае импортирования
пакета. Операция импортирования может также загружать менее обычные файлы, такие как компоненты из архивов в формате ZIP, классы Java
в Jython – версии Python, компоненты .NET в IronPython и статически
скомпонованные расширения, написанные на языке C, которые вообще не
представлены в виде файлов. С помощью программных ловушек, которые
имеет реализация операции импорта, можно загрузить все, что угодно.
5. Пространство имен – это независимый пакет переменных, известных как
атрибуты пространства имен объекта. Пространство имен модуля содер-
жит все имена, присваивание значений которым производится программ-
ным кодом на верхнем уровне модуля (то есть не вложенным в инструкции
def или class). С технической точки зрения глобальная область видимости
трансформируется в пространство имен атрибутов объекта модуля. Про-
странство имен модуля может изменяться с помощью операций присваива-
ния из других файлов, которые импортируют данный модуль, хотя это и не
приветствуется (подробнее об этом рассказывается в главе 17).

## Контрольные вопросы
1. Как создать модуль?
2. Как взаимосвязаны инструкции from и import?
3. Какое отношение к операции импортирования имеет функция reload?
4. Когда вместо инструкции from следует использовать инструкцию import?
5. Назовите три потенциальных ловушки инструкции from.

## Ответы
1. Чтобы создать модуль, достаточно просто создать текстовый файл с ин-
струкциями на языке Python; любой файл с исходным программным кодом
автоматически становится модулем – нет никаких синтаксических кон-
струкций для его объявления. Можно также создать модуль, написав про-
граммный код на другом языке программирования, таком как C или Java,
но такие модули находятся вне рассмотрения этой книги.
2. Инструкция from импортирует модуль целиком, как и инструкция import,
но кроме этого она еще копирует одно или более имен из импортируемого
модуля в ту область видимости, где находится инструкция from. Это позво-
ляет использовать импортированные имена напрямую (name), без дополне-
ния их именем модуля (module.name).
3. По умолчанию модуль импортируется один раз за все время выполнения
программы. Функция reload принудительно выполняет повторное импор-
тирование. Она часто используется, чтобы загрузить новую версию исходного
программного кода модуля в процессе разработки и в случаях динами-
ческой настройки.
4. Инструкция import обязательно должна использоваться вместо инструкции
from, только когда необходимо обеспечить доступ к одному и тому же имени
в двух разных модулях, – поскольку вы будете вынуждены указывать име-
на вмещающих модулей, эти два имени будут уникальны.
5. Инструкция from может делать непонятным смысл переменной (в каком
модуле она определена), вызывать проблемы при использовании функ-
ции reload (имена могут ссылаться на прежние версии объектов) и может
повреждать пространства имен (может приводить к перезаписи значений
имен, используемых в вашей области видимости). Самой худшей, во многих
отношениях, является форма from * – она может приводить к серьезным по-
вреждениям пространств имен и скрывать смысл переменных – эту форму
инструкции следует использовать с большой осторожностью.

## Контрольные вопросы
1. Для чего служит файл \_\_init\_\_.py в каталогах пакетов модулей?
2. Как избежать необходимости снова и снова вводить полное имя пакета при
каждом обращении к содержимому пакетов?
3. В каких каталогах необходимо создавать файл \_\_init\_\_.py?
4. В каких случаях вместо инструкции from приходится использовать ин-
струкцию import?
5. Чем отличаются инструкции from mypkg import spam и from . import spam?

## Ответы
1. Файлы \_\_init\_\_.py служат для объявления и инициализации пакета, – ин-
терпретатор автоматически запускает программный код в этих файлах,
когда каталог импортируется программой впервые. Переменные, которым
выполняется присваивание в этих файлах, становятся атрибутами объекта
модуля для соответствующего каталога. Присутствие этих файлов в ката-
логах пакетов обязательно – вы не сможете импортировать пакеты при от-
сутствии этих файлов в каталогах.
2. Используйте инструкцию from, чтобы скопировать имена из пакета или
воспользуйтесь расширением as инструкции import, чтобы переименовать
полный путь в короткий синоним. В обоих случаях полный путь будет при-
сутствовать только в одном месте – в инструкции from или import.
3. Каждый каталог, перечисленный в инструкции import или from, должен со-
держать файл \_\_init\_\_.py. Другие каталоги, включая каталог, содержащий
самый первый компонент пути к пакету, не требуют наличия этого файла.
4. Инструкция import должна использоваться вместо инструкции from, только
если вам необходимо обеспечить доступ к одному и тому же имени более чем
в одном каталоге. Благодаря инструкции import употребление полного пути
обеспечивает уникальность ссылок, тогда как инструкция from допускает
наличие только одной версии любого имени.
5. Инструкция from mypkg import spam выполняет импорт по абсолютному
пути – при поиске mypkg она пропускает каталог пакета и пользуется спи-
ском каталогов в sys.path. Инструкция from . import spam, напротив, выпол-
няет импорт относительно текущего пакета – поиск модуля spam выпол-
няется относительно пакета, внутри которого находится эта инструкция.
