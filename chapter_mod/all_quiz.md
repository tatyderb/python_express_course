# Контрольные вопросы и ответы по разделам

Лутц, стр 621

## Контрольные вопросы
1. Каким образом файл с исходным программным кодом модуля превращается в объект модуля?
2. Зачем может потребоваться настраивать значение переменной окружения
PYTHONPATH?
3. Назовите четыре основных компонента, составляющих путь поиска модулей.
4. Назовите четыре типа файлов, которые могут загружаться операцией импортирования.
5. Что такое пространство имен, и что содержит пространство имен модуля?

## Ответы
1. Файл с исходными текстами модуля автоматически превращается в объект модуля в результате выполнения операции импортирования. С технической точки зрения исходный программный код модуля выполняется во
время импортирования, инструкция за инструкцией, и все имена, которым
по мере выполнения операций будут присвоены значения, превращаются
в атрибуты объекта модуля.
2. Настройка переменной PYTHONPATH может потребоваться только в случае необходимости импортировать модули, размещенные в каталогах, отличных
от того, в котором вы работаете (то есть отличных от текущего каталога при
работе в интерактивной оболочке или от каталога, где находится главный
файл программы).
3. Четырьмя основными компонентами, составляющими путь поиска модулей, являются: домашний каталог главного файла программы (каталог,
в котором он находится), все каталоги, перечисленные в переменной окружения PYTHONPATH, каталоги стандартной библиотеки и все каталоги в файлах с расширением .pth, размещенных в стандартных местах. Из них доступны для настройки переменная окружения PYTHONPATH и файлы с расширением .pth.
4. Интерпретатор Python может загружать файлы с исходными текстами
(.py), файлы с байт-кодом (.pyc), файлы расширений, написанных на языке C (например, файлы с расширением .so в Linux или с расширением .dll
в Windows), или каталог с указанным именем, в случае импортирования
пакета. Операция импортирования может также загружать менее обычные файлы, такие как компоненты из архивов в формате ZIP, классы Java
в Jython – версии Python, компоненты .NET в IronPython и статически
скомпонованные расширения, написанные на языке C, которые вообще не
представлены в виде файлов. С помощью программных ловушек, которые
имеет реализация операции импорта, можно загрузить все, что угодно.
5. Пространство имен – это независимый пакет переменных, известных как
атрибуты пространства имен объекта. Пространство имен модуля содер-
жит все имена, присваивание значений которым производится программ-
ным кодом на верхнем уровне модуля (то есть не вложенным в инструкции
def или class). С технической точки зрения глобальная область видимости
трансформируется в пространство имен атрибутов объекта модуля. Про-
странство имен модуля может изменяться с помощью операций присваива-
ния из других файлов, которые импортируют данный модуль, хотя это и не
приветствуется (подробнее об этом рассказывается в главе 17).

## Контрольные вопросы
1. Как создать модуль?
2. Как взаимосвязаны инструкции from и import?
3. Какое отношение к операции импортирования имеет функция reload?
4. Когда вместо инструкции from следует использовать инструкцию import?
5. Назовите три потенциальных ловушки инструкции from.

## Ответы
1. Чтобы создать модуль, достаточно просто создать текстовый файл с ин-
струкциями на языке Python; любой файл с исходным программным кодом
автоматически становится модулем – нет никаких синтаксических кон-
струкций для его объявления. Можно также создать модуль, написав про-
граммный код на другом языке программирования, таком как C или Java,
но такие модули находятся вне рассмотрения этой книги.
2. Инструкция from импортирует модуль целиком, как и инструкция import,
но кроме этого она еще копирует одно или более имен из импортируемого
модуля в ту область видимости, где находится инструкция from. Это позво-
ляет использовать импортированные имена напрямую (name), без дополне-
ния их именем модуля (module.name).
3. По умолчанию модуль импортируется один раз за все время выполнения
программы. Функция reload принудительно выполняет повторное импор-
тирование. Она часто используется, чтобы загрузить новую версию исходного
программного кода модуля в процессе разработки и в случаях динами-
ческой настройки.
4. Инструкция import обязательно должна использоваться вместо инструкции
from, только когда необходимо обеспечить доступ к одному и тому же имени
в двух разных модулях, – поскольку вы будете вынуждены указывать име-
на вмещающих модулей, эти два имени будут уникальны.
5. Инструкция from может делать непонятным смысл переменной (в каком
модуле она определена), вызывать проблемы при использовании функ-
ции reload (имена могут ссылаться на прежние версии объектов) и может
повреждать пространства имен (может приводить к перезаписи значений
имен, используемых в вашей области видимости). Самой худшей, во многих
отношениях, является форма from * – она может приводить к серьезным по-
вреждениям пространств имен и скрывать смысл переменных – эту форму
инструкции следует использовать с большой осторожностью.