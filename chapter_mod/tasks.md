# Задачи на исключения

Реализовать сложение и скалярное умножение векторов, чтобы возбуждалось исключение, если длина векторов не совпадает.

Исследовать работу кода, если используется функция zip, map, reduce  и тп.

# Задачи

```python
from os.path import dirname
sys.path.append(dirname(__file__))
```

## импорт модуля

В одном файле определите функцию, которая считает nod для двух целых чисел по алгоритму Евклида.

В другом файле этой же директории используйте функцию nod (например, дана дробь в виде числителя и знаменателя через пробел, сократите дробь и напечатайте ее в виде "числитель / знаменатель".

## импорт пакета

## относительный импорт

Импортируйте модуль как .b, как ..b и как ..subdir2.b

### тесты в отдельной директории

Возьмите задачу и напишите тесты по этой задаче в отдельной директории tests. Т.е. для файла a.py разместите тесты в tests/a.py


# Задачи из Лутца

Упражнения к пятой части
Решения приводятся в разделе «Часть V, Модули» приложения A.
1. Основы импортирования. Напишите программу, которая подсчитывает ко-
личество строк и символов в файле (в духе утилиты wc в операционной систе-
мы UNIX). В своем текстовом редакторе создайте модуль с именем mymod.
py, который экспортирует три имени:
•• Функцию countLines(name), которая читает входной файл и подсчитывает
число строк в нем (подсказка: большую часть работы можно выполнить
с помощью метода file.readlines, а оставшуюся часть – с помощью функ-
ции len).
•• Функцию countChars(name), которая читает входной файл и подсчитыва-
ет число символов в нем (подсказка: метод file.read возвращает единую
строку).
•• Функцию test(name), которая вызывает две предыдущие функции с за-
данным именем файла. Вообще говоря, имя файла можно жестко
определить в программном коде, принимать ввод от пользователя или
принимать имя как параметр командной строки через список sys.argv –
но пока исходите из предположения, что оно передается как аргумент
функции.
Все три функции в модуле mymod должны принимать имя файла в виде стро-
ки. Если размер любой из функций превысит две-три строки, это значит, что
вы делаете лишнюю работу, – используйте подсказки, которые я вам дал!

Затем проверьте свой модуль в интерактивной оболочке, используя ин-
струкцию import и полные имена экспортируемых функций. Следует ли до-
бавить в переменную PYTHONPATH каталог, где находится ваш файл mymod.
py? Попробуйте проверить модуль на самом себе: например, test(“mymod.py”).
Обратите внимание, что функция test открывает файл дважды, – если вы
достаточно честолюбивы, попробуйте оптимизировать программный код,
передавая двум функциям счета объект открытого файла (подсказка: метод
file.seek(0) выполняет переустановку указателя в начало файла).
2. from/from *. Проверьте модуль mymod из упражнения 1 в интерактивной обо-
лочке, используя для загрузки экспортируемых имен инструкцию from –
сначала по имени, а потом с помощью формы from *.
3. __main__. Добавьте в модуль mymod строку, в которой автоматически про-
изводился бы вызов функции test, только когда модуль выполняется как
самостоятельный сценарий, а не во время импортирования. Добавляемая
вами строка, вероятно, должна содержать проверку значения атрибута
__name__ на равенство строке “__main__”, как было показано в этой главе.
Попробуйте запустить модуль из системной командной строки, затем им-
портируйте модуль и проверьте работу функций в интерактивном режиме.
Будут ли работать функции в обоих режимах?
4. Вложенное импортирование. Напишите второй модуль myclient.py, кото-
рый импортирует модуль mymod и проверяет работу его функций, затем за-
пустите myclient из системной командной строки. Будут ли доступны функ-
ции из mymod на верхнем уровне myclient, если импортировать их с помощью
инструкции from? А если они будут импортированы с помощью инструкции
import? Попробуйте реализовать оба варианта в myclient и проверить в инте-
рактивном режиме, импортируя модуль myclient и проверяя содержимое его
атрибута __dict__.
5. Импорт пакетов. Импортируйте ваш файл из пакета. Создайте каталог
с именем mypkg, вложенный в каталог, находящийся в пути поиска моду-
лей. Переместите в него файл mymod.py, созданный в упражнении 1 или 3,
и попробуйте импортировать его как пакет, инструкцией import mypkg.mymod.
Вам потребуется добавить файл __init__.py в каталог, куда был помещен
ваш модуль. Это упражнение должно работать на всех основных платфор-
мах Python (это одна из причин, почему в языке Python в качестве разде-
лителя компонентов пути используется символ «.»). Каталог пакета может
быть простым подкаталогом в вашем рабочем каталоге – в этом случае он
будет обнаружен интерпретатором при поиске в домашнем каталоге и вам
не потребуется настраивать путь поиска. Добавьте какой-нибудь программ-
ный код в __init__.py и посмотрите, будет ли он выполняться при каждой
операции импортирования.
6. Повторная загрузка. Поэкспериментируйте с возможностью повторной за-
грузки модуля: выполните тесты, которые приводятся в примере changer.py
в главе 22, многократно изменяя текст сообщения и/или поведение модуля,
без остановки интерактивного сеанса работы с интерпретатором Python.
В зависимости от операционной системы файл модуля можно было бы ре-
дактировать в другом окне или, приостановив интерпретатор, редактиро-
вать модуль в том же окне (в UNIX комбинация клавиш Ctrl-Z обычно при-
водит к приостановке текущего процесса, а команда fg – возобновляет его
работу).

7. Попробуйте импортировать модули рекурсивно. Что произойдет?

## запуск файла

## запуск модуля
