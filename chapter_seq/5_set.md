# Множество (set)

* **set** - множество. В нем нет одинаковых элементов. Его можно изменять.

* **frozenset** - множество. В нем нет одинаковых элементов. Его НЕЛЬЗЯ изменять.

**Порядок перебора элементов множества не определен.**

То есть в множестве определены операции **in**, **len**, возможен перебор **for .. in**, но нельзя взять i-тый элемент.

Можно взять `enumerate(a)`, но порядок перебора может быть разный.

## Создание множества

Множество пишем в {  }.

Пустое множество:
```python
a = set()   # только так
a = {}      # это НЕ множество, это словарь
```

Создаем множество:
```python
a = [1, 5, 17, 5, -22, 4, 4, 4]   # сделали list
print(a)                          # 1 5 17 5 -22 4 4 4
b = set(a)                        # сделали set из list
print(b)                          # 1 5 17 -22 4
c = {1, 5, 17, 5, -22, 4, 4, 4}   # сделали set
print(c)                          # 1 5 17 -22 4
```
## Что может быть элементом множества?

Только хешируемый объект. Т.е. объект, для которого определена функция **\_\_hash\_\_()** - она возвращает все время одно и то же значение на протяжении всей жизни объекта. Эти объекты можно сравнить на равенство, используя **\_\_eq\_\_()**

* int, float, str, tuple, frozenset - хешируемые объекты, могут быть добавлены в множество;
* list, dict, set - нехэшируемые, так как значение хеша зависит от значений их элементов (а они могут изменяться).

Хешируемый != неизменный. Объект класса Person может быть хешируемым, если в классе определена фукнция \_\_hash\_\_(). Она может возвращать, например, СНИЛС человека или любой другой его неизменяемый идентификатор.
При этом данные о человеке могут меняться (например, смена фамилии).

## Методы множества

```python
a = {1, 3, 5, 11, 12, 13}
b = {5, 1, 3, 21, 22, 23}
c = {1, 3, 5}
d = {3, 1, 5}
w = {2, 8}
```
| Операция | Значение | Результат |
|---|-----|---|
| a.add(7) | добавить 7 в множество a | |
| a.remove\(5\) | удалить 5 из a (если нет, KeyError exception)|{1, 3, 11, 12, 13}|
| a.discard\(5\) | удалить 5 из a если элемент есть |{1, 3, 11, 12, 13}|
| a.pop() | удаляет случайный элемент из множества (или KeyError, если множество пустое) | |
| a.clear() | удалить все элементы из а | |
| a.copy() | копия множества | |
| len(a) | число элементов в множестве | 6 |
| x in a | элемент х в множестве а | |
| x not in a | элемент х НЕ в множестве а | |
| a.**isdisjoint**(w) | True, если у множеств нет общих элементов | |
| c == d | множества с и d равны | |
| с &lt; a | c содержится в множестве a, но не равно ему | |
| c.issubset(a)<br/>с &lt;= a | c содержится в множестве a  | |
| a &gt; c | a содержит в себе c | |
| a.issuperset(c)<br/>a &gt;= c | a содержит в себе c, но не равно ему | |
| a.union(b)<br/>a &#124; b | объединение множеств (новое) | {1, 3, 5, 11, 12, 13, 21, 22, 23}|
| a.update(b)<br/>a &#124;= b | объединение множеств (изменяется а) | {1, 3, 5, 11, 12, 13, 21, 22, 23}|
| a.intersection(b)<br/>a &amp; b | пересечение множеств (новое) | {1, 3, 5} |
| a.intersection_update(b)<br/>a &amp;= b | оставляет во множестве а пересечение множеств а и b | {1, 3, 5} |
| a.difference(c)<br/>a - c | вычитание (новое множество) | {11, 12, 13} |
| a.difference_update(c)<br/>a -= c | удаляет из множества а все элементы, которые присутствуют в с | a = {11, 12, 13} |
| a.symmetric_difference(b)<br/>a ^ b | XOR (новое множество) | {11, 12, 13, 21, 22, 23} |
| a.symmetric_difference_update(b)<br/>a ^= b | XOR (изменяем а) | {11, 12, 13, 21, 22, 23} |

Применение множеств:
* убрать повторения;
* список уже обработанных имен и "уже обрабатывали?"

Если нет аргументов командной строки или указаны -h или --help:
```python
if len(sys.argv) == 1 or sys.argv[1] in {"-h", "--help"}
```
